/**
 * Generated by orval v8.0.0 üç∫
 * Do not edit manually.
 * Spotify Web API with fixes and improvements from sonallux
 * You can use Spotify's Web API to discover music and podcasts, manage your Spotify library, control audio playback, and much more. Browse our available Web API endpoints using the sidebar at left, or via the navigation bar on top of this page on smaller screens.

In order to make successful Web API requests your app will need a valid access token. One can be obtained through <a href="https://developer.spotify.com/documentation/general/guides/authorization-guide/">OAuth 2.0</a>.

The base URI for all Web API requests is `https://api.spotify.com/v1`.

Need help? See our <a href="https://developer.spotify.com/documentation/web-api/guides/">Web API guides</a> for more information, or visit the <a href="https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer">Spotify for Developers community forum</a> to ask questions and connect with other developers.

 * OpenAPI spec version: 2023.8.30
 */
import useSwr from 'swr';
import type {
  Arguments,
  Key,
  SWRConfiguration
} from 'swr';

import useSWRMutation from 'swr/mutation';
import type {
  SWRMutationConfiguration
} from 'swr/mutation';

import type {
  AddToQueueParams,
  CursorPagedPlayHistoryResponse,
  ForbiddenResponse,
  GetInformationAboutTheUsersCurrentPlaybackParams,
  GetRecentlyPlayedParams,
  GetTheUsersCurrentlyPlayingTrackParams,
  ManyDevicesResponse,
  OneCurrentlyPlayingResponse,
  OneCurrentlyPlayingTrackResponse,
  PauseAUsersPlaybackParams,
  QueueResponse,
  SeekToPositionInCurrentlyPlayingTrackParams,
  SetRepeatModeOnUsersPlaybackParams,
  SetVolumeForUsersPlaybackParams,
  SkipUsersPlaybackToNextTrackParams,
  SkipUsersPlaybackToPreviousTrackParams,
  StartAUsersPlaybackBody,
  StartAUsersPlaybackParams,
  ToggleShuffleForUsersPlaybackParams,
  TooManyRequestsResponse,
  TransferAUsersPlaybackBody,
  UnauthorizedResponse
} from '../../model';



  
  
  
/**
 * Get information about the user‚Äôs current playback state, including track or episode, progress, and active device.

 * @summary Get Playback State

 */
export type getInformationAboutTheUsersCurrentPlaybackResponse200 = {
  data: OneCurrentlyPlayingResponse
  status: 200
}

export type getInformationAboutTheUsersCurrentPlaybackResponse204 = {
  data: void
  status: 204
}

export type getInformationAboutTheUsersCurrentPlaybackResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getInformationAboutTheUsersCurrentPlaybackResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getInformationAboutTheUsersCurrentPlaybackResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type getInformationAboutTheUsersCurrentPlaybackResponseSuccess = (getInformationAboutTheUsersCurrentPlaybackResponse200 | getInformationAboutTheUsersCurrentPlaybackResponse204) & {
  headers: Headers;
};
export type getInformationAboutTheUsersCurrentPlaybackResponseError = (getInformationAboutTheUsersCurrentPlaybackResponse401 | getInformationAboutTheUsersCurrentPlaybackResponse403 | getInformationAboutTheUsersCurrentPlaybackResponse429) & {
  headers: Headers;
};

export type getInformationAboutTheUsersCurrentPlaybackResponse = (getInformationAboutTheUsersCurrentPlaybackResponseSuccess | getInformationAboutTheUsersCurrentPlaybackResponseError)

export const getGetInformationAboutTheUsersCurrentPlaybackUrl = (params?: GetInformationAboutTheUsersCurrentPlaybackParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/me/player?${stringifiedParams}` : `https://api.spotify.com/v1/me/player`
}

export const getInformationAboutTheUsersCurrentPlayback = async (params?: GetInformationAboutTheUsersCurrentPlaybackParams, options?: RequestInit): Promise<getInformationAboutTheUsersCurrentPlaybackResponse> => {
  
  const res = await fetch(getGetInformationAboutTheUsersCurrentPlaybackUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getInformationAboutTheUsersCurrentPlaybackResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getInformationAboutTheUsersCurrentPlaybackResponse
}




export const getGetInformationAboutTheUsersCurrentPlaybackKey = (params?: GetInformationAboutTheUsersCurrentPlaybackParams,) => [`https://api.spotify.com/v1/me/player`, ...(params ? [params]: [])] as const;

export type GetInformationAboutTheUsersCurrentPlaybackQueryResult = NonNullable<Awaited<ReturnType<typeof getInformationAboutTheUsersCurrentPlayback>>>

/**
 * @summary Get Playback State

 */
export const useGetInformationAboutTheUsersCurrentPlayback = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params?: GetInformationAboutTheUsersCurrentPlaybackParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getInformationAboutTheUsersCurrentPlayback>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetInformationAboutTheUsersCurrentPlaybackKey(params) : null);
  const swrFn = () => getInformationAboutTheUsersCurrentPlayback(params, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Transfer playback to a new device and determine if it should start playing.

 * @summary Transfer Playback

 */
export type transferAUsersPlaybackResponse204 = {
  data: void
  status: 204
}

export type transferAUsersPlaybackResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type transferAUsersPlaybackResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type transferAUsersPlaybackResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type transferAUsersPlaybackResponseSuccess = (transferAUsersPlaybackResponse204) & {
  headers: Headers;
};
export type transferAUsersPlaybackResponseError = (transferAUsersPlaybackResponse401 | transferAUsersPlaybackResponse403 | transferAUsersPlaybackResponse429) & {
  headers: Headers;
};

export type transferAUsersPlaybackResponse = (transferAUsersPlaybackResponseSuccess | transferAUsersPlaybackResponseError)

export const getTransferAUsersPlaybackUrl = () => {


  

  return `https://api.spotify.com/v1/me/player`
}

export const transferAUsersPlayback = async (transferAUsersPlaybackBody: TransferAUsersPlaybackBody, options?: RequestInit): Promise<transferAUsersPlaybackResponse> => {
  
  const res = await fetch(getTransferAUsersPlaybackUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      transferAUsersPlaybackBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: transferAUsersPlaybackResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as transferAUsersPlaybackResponse
}




export const getTransferAUsersPlaybackMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: TransferAUsersPlaybackBody }) => {
    return transferAUsersPlayback(arg, options);
  }
}
export const getTransferAUsersPlaybackMutationKey = () => [`https://api.spotify.com/v1/me/player`] as const;

export type TransferAUsersPlaybackMutationResult = NonNullable<Awaited<ReturnType<typeof transferAUsersPlayback>>>

/**
 * @summary Transfer Playback

 */
export const useTransferAUsersPlayback = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof transferAUsersPlayback>>, TError, Key, TransferAUsersPlaybackBody, Awaited<ReturnType<typeof transferAUsersPlayback>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getTransferAUsersPlaybackMutationKey();
  const swrFn = getTransferAUsersPlaybackMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Get information about a user‚Äôs available devices.

 * @summary Get Available Devices

 */
export type getAUsersAvailableDevicesResponse200 = {
  data: ManyDevicesResponse
  status: 200
}

export type getAUsersAvailableDevicesResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getAUsersAvailableDevicesResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getAUsersAvailableDevicesResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type getAUsersAvailableDevicesResponseSuccess = (getAUsersAvailableDevicesResponse200) & {
  headers: Headers;
};
export type getAUsersAvailableDevicesResponseError = (getAUsersAvailableDevicesResponse401 | getAUsersAvailableDevicesResponse403 | getAUsersAvailableDevicesResponse429) & {
  headers: Headers;
};

export type getAUsersAvailableDevicesResponse = (getAUsersAvailableDevicesResponseSuccess | getAUsersAvailableDevicesResponseError)

export const getGetAUsersAvailableDevicesUrl = () => {


  

  return `https://api.spotify.com/v1/me/player/devices`
}

export const getAUsersAvailableDevices = async ( options?: RequestInit): Promise<getAUsersAvailableDevicesResponse> => {
  
  const res = await fetch(getGetAUsersAvailableDevicesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getAUsersAvailableDevicesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getAUsersAvailableDevicesResponse
}




export const getGetAUsersAvailableDevicesKey = () => [`https://api.spotify.com/v1/me/player/devices`] as const;

export type GetAUsersAvailableDevicesQueryResult = NonNullable<Awaited<ReturnType<typeof getAUsersAvailableDevices>>>

/**
 * @summary Get Available Devices

 */
export const useGetAUsersAvailableDevices = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getAUsersAvailableDevices>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetAUsersAvailableDevicesKey() : null);
  const swrFn = () => getAUsersAvailableDevices(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Get the object currently being played on the user's Spotify account.

 * @summary Get Currently Playing Track

 */
export type getTheUsersCurrentlyPlayingTrackResponse200 = {
  data: OneCurrentlyPlayingTrackResponse
  status: 200
}

export type getTheUsersCurrentlyPlayingTrackResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getTheUsersCurrentlyPlayingTrackResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getTheUsersCurrentlyPlayingTrackResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type getTheUsersCurrentlyPlayingTrackResponseSuccess = (getTheUsersCurrentlyPlayingTrackResponse200) & {
  headers: Headers;
};
export type getTheUsersCurrentlyPlayingTrackResponseError = (getTheUsersCurrentlyPlayingTrackResponse401 | getTheUsersCurrentlyPlayingTrackResponse403 | getTheUsersCurrentlyPlayingTrackResponse429) & {
  headers: Headers;
};

export type getTheUsersCurrentlyPlayingTrackResponse = (getTheUsersCurrentlyPlayingTrackResponseSuccess | getTheUsersCurrentlyPlayingTrackResponseError)

export const getGetTheUsersCurrentlyPlayingTrackUrl = (params?: GetTheUsersCurrentlyPlayingTrackParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/me/player/currently-playing?${stringifiedParams}` : `https://api.spotify.com/v1/me/player/currently-playing`
}

export const getTheUsersCurrentlyPlayingTrack = async (params?: GetTheUsersCurrentlyPlayingTrackParams, options?: RequestInit): Promise<getTheUsersCurrentlyPlayingTrackResponse> => {
  
  const res = await fetch(getGetTheUsersCurrentlyPlayingTrackUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getTheUsersCurrentlyPlayingTrackResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getTheUsersCurrentlyPlayingTrackResponse
}




export const getGetTheUsersCurrentlyPlayingTrackKey = (params?: GetTheUsersCurrentlyPlayingTrackParams,) => [`https://api.spotify.com/v1/me/player/currently-playing`, ...(params ? [params]: [])] as const;

export type GetTheUsersCurrentlyPlayingTrackQueryResult = NonNullable<Awaited<ReturnType<typeof getTheUsersCurrentlyPlayingTrack>>>

/**
 * @summary Get Currently Playing Track

 */
export const useGetTheUsersCurrentlyPlayingTrack = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params?: GetTheUsersCurrentlyPlayingTrackParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getTheUsersCurrentlyPlayingTrack>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetTheUsersCurrentlyPlayingTrackKey(params) : null);
  const swrFn = () => getTheUsersCurrentlyPlayingTrack(params, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Start a new context or resume current playback on the user's active device.

 * @summary Start/Resume Playback

 */
export type startAUsersPlaybackResponse204 = {
  data: void
  status: 204
}

export type startAUsersPlaybackResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type startAUsersPlaybackResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type startAUsersPlaybackResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type startAUsersPlaybackResponseSuccess = (startAUsersPlaybackResponse204) & {
  headers: Headers;
};
export type startAUsersPlaybackResponseError = (startAUsersPlaybackResponse401 | startAUsersPlaybackResponse403 | startAUsersPlaybackResponse429) & {
  headers: Headers;
};

export type startAUsersPlaybackResponse = (startAUsersPlaybackResponseSuccess | startAUsersPlaybackResponseError)

export const getStartAUsersPlaybackUrl = (params?: StartAUsersPlaybackParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/me/player/play?${stringifiedParams}` : `https://api.spotify.com/v1/me/player/play`
}

export const startAUsersPlayback = async (startAUsersPlaybackBody: StartAUsersPlaybackBody,
    params?: StartAUsersPlaybackParams, options?: RequestInit): Promise<startAUsersPlaybackResponse> => {
  
  const res = await fetch(getStartAUsersPlaybackUrl(params),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      startAUsersPlaybackBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: startAUsersPlaybackResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as startAUsersPlaybackResponse
}




export const getStartAUsersPlaybackMutationFetcher = (params?: StartAUsersPlaybackParams, options?: RequestInit) => {
  return (_: Key, { arg }: { arg: StartAUsersPlaybackBody }) => {
    return startAUsersPlayback(arg, params, options);
  }
}
export const getStartAUsersPlaybackMutationKey = (params?: StartAUsersPlaybackParams,) => [`https://api.spotify.com/v1/me/player/play`, ...(params ? [params]: [])] as const;

export type StartAUsersPlaybackMutationResult = NonNullable<Awaited<ReturnType<typeof startAUsersPlayback>>>

/**
 * @summary Start/Resume Playback

 */
export const useStartAUsersPlayback = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params?: StartAUsersPlaybackParams, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof startAUsersPlayback>>, TError, Key, StartAUsersPlaybackBody, Awaited<ReturnType<typeof startAUsersPlayback>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getStartAUsersPlaybackMutationKey(params);
  const swrFn = getStartAUsersPlaybackMutationFetcher(params, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Pause playback on the user's account.

 * @summary Pause Playback

 */
export type pauseAUsersPlaybackResponse204 = {
  data: void
  status: 204
}

export type pauseAUsersPlaybackResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type pauseAUsersPlaybackResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type pauseAUsersPlaybackResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type pauseAUsersPlaybackResponseSuccess = (pauseAUsersPlaybackResponse204) & {
  headers: Headers;
};
export type pauseAUsersPlaybackResponseError = (pauseAUsersPlaybackResponse401 | pauseAUsersPlaybackResponse403 | pauseAUsersPlaybackResponse429) & {
  headers: Headers;
};

export type pauseAUsersPlaybackResponse = (pauseAUsersPlaybackResponseSuccess | pauseAUsersPlaybackResponseError)

export const getPauseAUsersPlaybackUrl = (params?: PauseAUsersPlaybackParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/me/player/pause?${stringifiedParams}` : `https://api.spotify.com/v1/me/player/pause`
}

export const pauseAUsersPlayback = async (params?: PauseAUsersPlaybackParams, options?: RequestInit): Promise<pauseAUsersPlaybackResponse> => {
  
  const res = await fetch(getPauseAUsersPlaybackUrl(params),
  {      
    ...options,
    method: 'PUT'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: pauseAUsersPlaybackResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as pauseAUsersPlaybackResponse
}




export const getPauseAUsersPlaybackMutationFetcher = (params?: PauseAUsersPlaybackParams, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }) => {
    return pauseAUsersPlayback(params, options);
  }
}
export const getPauseAUsersPlaybackMutationKey = (params?: PauseAUsersPlaybackParams,) => [`https://api.spotify.com/v1/me/player/pause`, ...(params ? [params]: [])] as const;

export type PauseAUsersPlaybackMutationResult = NonNullable<Awaited<ReturnType<typeof pauseAUsersPlayback>>>

/**
 * @summary Pause Playback

 */
export const usePauseAUsersPlayback = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params?: PauseAUsersPlaybackParams, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof pauseAUsersPlayback>>, TError, Key, Arguments, Awaited<ReturnType<typeof pauseAUsersPlayback>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getPauseAUsersPlaybackMutationKey(params);
  const swrFn = getPauseAUsersPlaybackMutationFetcher(params, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Skips to next track in the user‚Äôs queue.

 * @summary Skip To Next

 */
export type skipUsersPlaybackToNextTrackResponse204 = {
  data: void
  status: 204
}

export type skipUsersPlaybackToNextTrackResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type skipUsersPlaybackToNextTrackResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type skipUsersPlaybackToNextTrackResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type skipUsersPlaybackToNextTrackResponseSuccess = (skipUsersPlaybackToNextTrackResponse204) & {
  headers: Headers;
};
export type skipUsersPlaybackToNextTrackResponseError = (skipUsersPlaybackToNextTrackResponse401 | skipUsersPlaybackToNextTrackResponse403 | skipUsersPlaybackToNextTrackResponse429) & {
  headers: Headers;
};

export type skipUsersPlaybackToNextTrackResponse = (skipUsersPlaybackToNextTrackResponseSuccess | skipUsersPlaybackToNextTrackResponseError)

export const getSkipUsersPlaybackToNextTrackUrl = (params?: SkipUsersPlaybackToNextTrackParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/me/player/next?${stringifiedParams}` : `https://api.spotify.com/v1/me/player/next`
}

export const skipUsersPlaybackToNextTrack = async (params?: SkipUsersPlaybackToNextTrackParams, options?: RequestInit): Promise<skipUsersPlaybackToNextTrackResponse> => {
  
  const res = await fetch(getSkipUsersPlaybackToNextTrackUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: skipUsersPlaybackToNextTrackResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as skipUsersPlaybackToNextTrackResponse
}




export const getSkipUsersPlaybackToNextTrackMutationFetcher = (params?: SkipUsersPlaybackToNextTrackParams, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }) => {
    return skipUsersPlaybackToNextTrack(params, options);
  }
}
export const getSkipUsersPlaybackToNextTrackMutationKey = (params?: SkipUsersPlaybackToNextTrackParams,) => [`https://api.spotify.com/v1/me/player/next`, ...(params ? [params]: [])] as const;

export type SkipUsersPlaybackToNextTrackMutationResult = NonNullable<Awaited<ReturnType<typeof skipUsersPlaybackToNextTrack>>>

/**
 * @summary Skip To Next

 */
export const useSkipUsersPlaybackToNextTrack = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params?: SkipUsersPlaybackToNextTrackParams, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof skipUsersPlaybackToNextTrack>>, TError, Key, Arguments, Awaited<ReturnType<typeof skipUsersPlaybackToNextTrack>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getSkipUsersPlaybackToNextTrackMutationKey(params);
  const swrFn = getSkipUsersPlaybackToNextTrackMutationFetcher(params, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Skips to previous track in the user‚Äôs queue.

 * @summary Skip To Previous

 */
export type skipUsersPlaybackToPreviousTrackResponse204 = {
  data: void
  status: 204
}

export type skipUsersPlaybackToPreviousTrackResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type skipUsersPlaybackToPreviousTrackResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type skipUsersPlaybackToPreviousTrackResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type skipUsersPlaybackToPreviousTrackResponseSuccess = (skipUsersPlaybackToPreviousTrackResponse204) & {
  headers: Headers;
};
export type skipUsersPlaybackToPreviousTrackResponseError = (skipUsersPlaybackToPreviousTrackResponse401 | skipUsersPlaybackToPreviousTrackResponse403 | skipUsersPlaybackToPreviousTrackResponse429) & {
  headers: Headers;
};

export type skipUsersPlaybackToPreviousTrackResponse = (skipUsersPlaybackToPreviousTrackResponseSuccess | skipUsersPlaybackToPreviousTrackResponseError)

export const getSkipUsersPlaybackToPreviousTrackUrl = (params?: SkipUsersPlaybackToPreviousTrackParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/me/player/previous?${stringifiedParams}` : `https://api.spotify.com/v1/me/player/previous`
}

export const skipUsersPlaybackToPreviousTrack = async (params?: SkipUsersPlaybackToPreviousTrackParams, options?: RequestInit): Promise<skipUsersPlaybackToPreviousTrackResponse> => {
  
  const res = await fetch(getSkipUsersPlaybackToPreviousTrackUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: skipUsersPlaybackToPreviousTrackResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as skipUsersPlaybackToPreviousTrackResponse
}




export const getSkipUsersPlaybackToPreviousTrackMutationFetcher = (params?: SkipUsersPlaybackToPreviousTrackParams, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }) => {
    return skipUsersPlaybackToPreviousTrack(params, options);
  }
}
export const getSkipUsersPlaybackToPreviousTrackMutationKey = (params?: SkipUsersPlaybackToPreviousTrackParams,) => [`https://api.spotify.com/v1/me/player/previous`, ...(params ? [params]: [])] as const;

export type SkipUsersPlaybackToPreviousTrackMutationResult = NonNullable<Awaited<ReturnType<typeof skipUsersPlaybackToPreviousTrack>>>

/**
 * @summary Skip To Previous

 */
export const useSkipUsersPlaybackToPreviousTrack = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params?: SkipUsersPlaybackToPreviousTrackParams, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof skipUsersPlaybackToPreviousTrack>>, TError, Key, Arguments, Awaited<ReturnType<typeof skipUsersPlaybackToPreviousTrack>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getSkipUsersPlaybackToPreviousTrackMutationKey(params);
  const swrFn = getSkipUsersPlaybackToPreviousTrackMutationFetcher(params, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Seeks to the given position in the user‚Äôs currently playing track.

 * @summary Seek To Position

 */
export type seekToPositionInCurrentlyPlayingTrackResponse204 = {
  data: void
  status: 204
}

export type seekToPositionInCurrentlyPlayingTrackResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type seekToPositionInCurrentlyPlayingTrackResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type seekToPositionInCurrentlyPlayingTrackResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type seekToPositionInCurrentlyPlayingTrackResponseSuccess = (seekToPositionInCurrentlyPlayingTrackResponse204) & {
  headers: Headers;
};
export type seekToPositionInCurrentlyPlayingTrackResponseError = (seekToPositionInCurrentlyPlayingTrackResponse401 | seekToPositionInCurrentlyPlayingTrackResponse403 | seekToPositionInCurrentlyPlayingTrackResponse429) & {
  headers: Headers;
};

export type seekToPositionInCurrentlyPlayingTrackResponse = (seekToPositionInCurrentlyPlayingTrackResponseSuccess | seekToPositionInCurrentlyPlayingTrackResponseError)

export const getSeekToPositionInCurrentlyPlayingTrackUrl = (params: SeekToPositionInCurrentlyPlayingTrackParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/me/player/seek?${stringifiedParams}` : `https://api.spotify.com/v1/me/player/seek`
}

export const seekToPositionInCurrentlyPlayingTrack = async (params: SeekToPositionInCurrentlyPlayingTrackParams, options?: RequestInit): Promise<seekToPositionInCurrentlyPlayingTrackResponse> => {
  
  const res = await fetch(getSeekToPositionInCurrentlyPlayingTrackUrl(params),
  {      
    ...options,
    method: 'PUT'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: seekToPositionInCurrentlyPlayingTrackResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as seekToPositionInCurrentlyPlayingTrackResponse
}




export const getSeekToPositionInCurrentlyPlayingTrackMutationFetcher = (params: SeekToPositionInCurrentlyPlayingTrackParams, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }) => {
    return seekToPositionInCurrentlyPlayingTrack(params, options);
  }
}
export const getSeekToPositionInCurrentlyPlayingTrackMutationKey = (params: SeekToPositionInCurrentlyPlayingTrackParams,) => [`https://api.spotify.com/v1/me/player/seek`, ...(params ? [params]: [])] as const;

export type SeekToPositionInCurrentlyPlayingTrackMutationResult = NonNullable<Awaited<ReturnType<typeof seekToPositionInCurrentlyPlayingTrack>>>

/**
 * @summary Seek To Position

 */
export const useSeekToPositionInCurrentlyPlayingTrack = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params: SeekToPositionInCurrentlyPlayingTrackParams, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof seekToPositionInCurrentlyPlayingTrack>>, TError, Key, Arguments, Awaited<ReturnType<typeof seekToPositionInCurrentlyPlayingTrack>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getSeekToPositionInCurrentlyPlayingTrackMutationKey(params);
  const swrFn = getSeekToPositionInCurrentlyPlayingTrackMutationFetcher(params, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Set the repeat mode for the user's playback. Options are repeat-track,
repeat-context, and off.

 * @summary Set Repeat Mode

 */
export type setRepeatModeOnUsersPlaybackResponse204 = {
  data: void
  status: 204
}

export type setRepeatModeOnUsersPlaybackResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type setRepeatModeOnUsersPlaybackResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type setRepeatModeOnUsersPlaybackResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type setRepeatModeOnUsersPlaybackResponseSuccess = (setRepeatModeOnUsersPlaybackResponse204) & {
  headers: Headers;
};
export type setRepeatModeOnUsersPlaybackResponseError = (setRepeatModeOnUsersPlaybackResponse401 | setRepeatModeOnUsersPlaybackResponse403 | setRepeatModeOnUsersPlaybackResponse429) & {
  headers: Headers;
};

export type setRepeatModeOnUsersPlaybackResponse = (setRepeatModeOnUsersPlaybackResponseSuccess | setRepeatModeOnUsersPlaybackResponseError)

export const getSetRepeatModeOnUsersPlaybackUrl = (params: SetRepeatModeOnUsersPlaybackParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/me/player/repeat?${stringifiedParams}` : `https://api.spotify.com/v1/me/player/repeat`
}

export const setRepeatModeOnUsersPlayback = async (params: SetRepeatModeOnUsersPlaybackParams, options?: RequestInit): Promise<setRepeatModeOnUsersPlaybackResponse> => {
  
  const res = await fetch(getSetRepeatModeOnUsersPlaybackUrl(params),
  {      
    ...options,
    method: 'PUT'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: setRepeatModeOnUsersPlaybackResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as setRepeatModeOnUsersPlaybackResponse
}




export const getSetRepeatModeOnUsersPlaybackMutationFetcher = (params: SetRepeatModeOnUsersPlaybackParams, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }) => {
    return setRepeatModeOnUsersPlayback(params, options);
  }
}
export const getSetRepeatModeOnUsersPlaybackMutationKey = (params: SetRepeatModeOnUsersPlaybackParams,) => [`https://api.spotify.com/v1/me/player/repeat`, ...(params ? [params]: [])] as const;

export type SetRepeatModeOnUsersPlaybackMutationResult = NonNullable<Awaited<ReturnType<typeof setRepeatModeOnUsersPlayback>>>

/**
 * @summary Set Repeat Mode

 */
export const useSetRepeatModeOnUsersPlayback = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params: SetRepeatModeOnUsersPlaybackParams, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof setRepeatModeOnUsersPlayback>>, TError, Key, Arguments, Awaited<ReturnType<typeof setRepeatModeOnUsersPlayback>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getSetRepeatModeOnUsersPlaybackMutationKey(params);
  const swrFn = getSetRepeatModeOnUsersPlaybackMutationFetcher(params, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Set the volume for the user‚Äôs current playback device.

 * @summary Set Playback Volume

 */
export type setVolumeForUsersPlaybackResponse204 = {
  data: void
  status: 204
}

export type setVolumeForUsersPlaybackResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type setVolumeForUsersPlaybackResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type setVolumeForUsersPlaybackResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type setVolumeForUsersPlaybackResponseSuccess = (setVolumeForUsersPlaybackResponse204) & {
  headers: Headers;
};
export type setVolumeForUsersPlaybackResponseError = (setVolumeForUsersPlaybackResponse401 | setVolumeForUsersPlaybackResponse403 | setVolumeForUsersPlaybackResponse429) & {
  headers: Headers;
};

export type setVolumeForUsersPlaybackResponse = (setVolumeForUsersPlaybackResponseSuccess | setVolumeForUsersPlaybackResponseError)

export const getSetVolumeForUsersPlaybackUrl = (params: SetVolumeForUsersPlaybackParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/me/player/volume?${stringifiedParams}` : `https://api.spotify.com/v1/me/player/volume`
}

export const setVolumeForUsersPlayback = async (params: SetVolumeForUsersPlaybackParams, options?: RequestInit): Promise<setVolumeForUsersPlaybackResponse> => {
  
  const res = await fetch(getSetVolumeForUsersPlaybackUrl(params),
  {      
    ...options,
    method: 'PUT'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: setVolumeForUsersPlaybackResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as setVolumeForUsersPlaybackResponse
}




export const getSetVolumeForUsersPlaybackMutationFetcher = (params: SetVolumeForUsersPlaybackParams, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }) => {
    return setVolumeForUsersPlayback(params, options);
  }
}
export const getSetVolumeForUsersPlaybackMutationKey = (params: SetVolumeForUsersPlaybackParams,) => [`https://api.spotify.com/v1/me/player/volume`, ...(params ? [params]: [])] as const;

export type SetVolumeForUsersPlaybackMutationResult = NonNullable<Awaited<ReturnType<typeof setVolumeForUsersPlayback>>>

/**
 * @summary Set Playback Volume

 */
export const useSetVolumeForUsersPlayback = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params: SetVolumeForUsersPlaybackParams, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof setVolumeForUsersPlayback>>, TError, Key, Arguments, Awaited<ReturnType<typeof setVolumeForUsersPlayback>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getSetVolumeForUsersPlaybackMutationKey(params);
  const swrFn = getSetVolumeForUsersPlaybackMutationFetcher(params, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Toggle shuffle on or off for user‚Äôs playback.

 * @summary Toggle Playback Shuffle

 */
export type toggleShuffleForUsersPlaybackResponse204 = {
  data: void
  status: 204
}

export type toggleShuffleForUsersPlaybackResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type toggleShuffleForUsersPlaybackResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type toggleShuffleForUsersPlaybackResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type toggleShuffleForUsersPlaybackResponseSuccess = (toggleShuffleForUsersPlaybackResponse204) & {
  headers: Headers;
};
export type toggleShuffleForUsersPlaybackResponseError = (toggleShuffleForUsersPlaybackResponse401 | toggleShuffleForUsersPlaybackResponse403 | toggleShuffleForUsersPlaybackResponse429) & {
  headers: Headers;
};

export type toggleShuffleForUsersPlaybackResponse = (toggleShuffleForUsersPlaybackResponseSuccess | toggleShuffleForUsersPlaybackResponseError)

export const getToggleShuffleForUsersPlaybackUrl = (params: ToggleShuffleForUsersPlaybackParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/me/player/shuffle?${stringifiedParams}` : `https://api.spotify.com/v1/me/player/shuffle`
}

export const toggleShuffleForUsersPlayback = async (params: ToggleShuffleForUsersPlaybackParams, options?: RequestInit): Promise<toggleShuffleForUsersPlaybackResponse> => {
  
  const res = await fetch(getToggleShuffleForUsersPlaybackUrl(params),
  {      
    ...options,
    method: 'PUT'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: toggleShuffleForUsersPlaybackResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as toggleShuffleForUsersPlaybackResponse
}




export const getToggleShuffleForUsersPlaybackMutationFetcher = (params: ToggleShuffleForUsersPlaybackParams, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }) => {
    return toggleShuffleForUsersPlayback(params, options);
  }
}
export const getToggleShuffleForUsersPlaybackMutationKey = (params: ToggleShuffleForUsersPlaybackParams,) => [`https://api.spotify.com/v1/me/player/shuffle`, ...(params ? [params]: [])] as const;

export type ToggleShuffleForUsersPlaybackMutationResult = NonNullable<Awaited<ReturnType<typeof toggleShuffleForUsersPlayback>>>

/**
 * @summary Toggle Playback Shuffle

 */
export const useToggleShuffleForUsersPlayback = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params: ToggleShuffleForUsersPlaybackParams, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof toggleShuffleForUsersPlayback>>, TError, Key, Arguments, Awaited<ReturnType<typeof toggleShuffleForUsersPlayback>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getToggleShuffleForUsersPlaybackMutationKey(params);
  const swrFn = getToggleShuffleForUsersPlaybackMutationFetcher(params, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Get tracks from the current user's recently played tracks.
_**Note**: Currently doesn't support podcast episodes._

 * @summary Get Recently Played Tracks

 */
export type getRecentlyPlayedResponse200 = {
  data: CursorPagedPlayHistoryResponse
  status: 200
}

export type getRecentlyPlayedResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getRecentlyPlayedResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getRecentlyPlayedResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type getRecentlyPlayedResponseSuccess = (getRecentlyPlayedResponse200) & {
  headers: Headers;
};
export type getRecentlyPlayedResponseError = (getRecentlyPlayedResponse401 | getRecentlyPlayedResponse403 | getRecentlyPlayedResponse429) & {
  headers: Headers;
};

export type getRecentlyPlayedResponse = (getRecentlyPlayedResponseSuccess | getRecentlyPlayedResponseError)

export const getGetRecentlyPlayedUrl = (params?: GetRecentlyPlayedParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/me/player/recently-played?${stringifiedParams}` : `https://api.spotify.com/v1/me/player/recently-played`
}

export const getRecentlyPlayed = async (params?: GetRecentlyPlayedParams, options?: RequestInit): Promise<getRecentlyPlayedResponse> => {
  
  const res = await fetch(getGetRecentlyPlayedUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getRecentlyPlayedResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getRecentlyPlayedResponse
}




export const getGetRecentlyPlayedKey = (params?: GetRecentlyPlayedParams,) => [`https://api.spotify.com/v1/me/player/recently-played`, ...(params ? [params]: [])] as const;

export type GetRecentlyPlayedQueryResult = NonNullable<Awaited<ReturnType<typeof getRecentlyPlayed>>>

/**
 * @summary Get Recently Played Tracks

 */
export const useGetRecentlyPlayed = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params?: GetRecentlyPlayedParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getRecentlyPlayed>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetRecentlyPlayedKey(params) : null);
  const swrFn = () => getRecentlyPlayed(params, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Get the list of objects that make up the user's queue.

 * @summary Get the User's Queue

 */
export type getQueueResponse200 = {
  data: QueueResponse
  status: 200
}

export type getQueueResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getQueueResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getQueueResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type getQueueResponseSuccess = (getQueueResponse200) & {
  headers: Headers;
};
export type getQueueResponseError = (getQueueResponse401 | getQueueResponse403 | getQueueResponse429) & {
  headers: Headers;
};

export type getQueueResponse = (getQueueResponseSuccess | getQueueResponseError)

export const getGetQueueUrl = () => {


  

  return `https://api.spotify.com/v1/me/player/queue`
}

export const getQueue = async ( options?: RequestInit): Promise<getQueueResponse> => {
  
  const res = await fetch(getGetQueueUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getQueueResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getQueueResponse
}




export const getGetQueueKey = () => [`https://api.spotify.com/v1/me/player/queue`] as const;

export type GetQueueQueryResult = NonNullable<Awaited<ReturnType<typeof getQueue>>>

/**
 * @summary Get the User's Queue

 */
export const useGetQueue = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getQueue>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetQueueKey() : null);
  const swrFn = () => getQueue(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Add an item to the end of the user's current playback queue.

 * @summary Add Item to Playback Queue

 */
export type addToQueueResponse204 = {
  data: void
  status: 204
}

export type addToQueueResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type addToQueueResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type addToQueueResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type addToQueueResponseSuccess = (addToQueueResponse204) & {
  headers: Headers;
};
export type addToQueueResponseError = (addToQueueResponse401 | addToQueueResponse403 | addToQueueResponse429) & {
  headers: Headers;
};

export type addToQueueResponse = (addToQueueResponseSuccess | addToQueueResponseError)

export const getAddToQueueUrl = (params: AddToQueueParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/me/player/queue?${stringifiedParams}` : `https://api.spotify.com/v1/me/player/queue`
}

export const addToQueue = async (params: AddToQueueParams, options?: RequestInit): Promise<addToQueueResponse> => {
  
  const res = await fetch(getAddToQueueUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: addToQueueResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as addToQueueResponse
}




export const getAddToQueueMutationFetcher = (params: AddToQueueParams, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }) => {
    return addToQueue(params, options);
  }
}
export const getAddToQueueMutationKey = (params: AddToQueueParams,) => [`https://api.spotify.com/v1/me/player/queue`, ...(params ? [params]: [])] as const;

export type AddToQueueMutationResult = NonNullable<Awaited<ReturnType<typeof addToQueue>>>

/**
 * @summary Add Item to Playback Queue

 */
export const useAddToQueue = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params: AddToQueueParams, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof addToQueue>>, TError, Key, Arguments, Awaited<ReturnType<typeof addToQueue>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getAddToQueueMutationKey(params);
  const swrFn = getAddToQueueMutationFetcher(params, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
