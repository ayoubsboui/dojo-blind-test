/**
 * Generated by orval v8.0.0 üç∫
 * Do not edit manually.
 * Spotify Web API with fixes and improvements from sonallux
 * You can use Spotify's Web API to discover music and podcasts, manage your Spotify library, control audio playback, and much more. Browse our available Web API endpoints using the sidebar at left, or via the navigation bar on top of this page on smaller screens.

In order to make successful Web API requests your app will need a valid access token. One can be obtained through <a href="https://developer.spotify.com/documentation/general/guides/authorization-guide/">OAuth 2.0</a>.

The base URI for all Web API requests is `https://api.spotify.com/v1`.

Need help? See our <a href="https://developer.spotify.com/documentation/web-api/guides/">Web API guides</a> for more information, or visit the <a href="https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer">Spotify for Developers community forum</a> to ask questions and connect with other developers.

 * OpenAPI spec version: 2023.8.30
 */
import useSwr from 'swr';
import type {
  Key,
  SWRConfiguration
} from 'swr';

import useSWRMutation from 'swr/mutation';
import type {
  SWRMutationConfiguration
} from 'swr/mutation';

import type {
  ArrayOfBooleansResponse,
  CheckUsersSavedTracksParams,
  ForbiddenResponse,
  GetRecommendationsParams,
  GetSeveralAudioFeaturesParams,
  GetSeveralTracksParams,
  GetTrackParams,
  GetUsersSavedTracksParams,
  ManyAudioFeaturesResponse,
  ManyTracksResponse,
  OneAudioAnalysisResponse,
  OneAudioFeaturesResponse,
  OneRecommendationsResponse,
  OneTrackResponse,
  PagingSavedTrackObjectResponse,
  RemoveTracksUserBody,
  RemoveTracksUserParams,
  SaveTracksUserBody,
  SaveTracksUserParams,
  TooManyRequestsResponse,
  UnauthorizedResponse
} from '../../model';



  
  
  
/**
 * Get Spotify catalog information for a single track identified by its
unique Spotify ID.

 * @summary Get Track

 */
export type getTrackResponse200 = {
  data: OneTrackResponse
  status: 200
}

export type getTrackResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getTrackResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getTrackResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type getTrackResponseSuccess = (getTrackResponse200) & {
  headers: Headers;
};
export type getTrackResponseError = (getTrackResponse401 | getTrackResponse403 | getTrackResponse429) & {
  headers: Headers;
};

export type getTrackResponse = (getTrackResponseSuccess | getTrackResponseError)

export const getGetTrackUrl = (id: string,
    params?: GetTrackParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/tracks/${id}?${stringifiedParams}` : `https://api.spotify.com/v1/tracks/${id}`
}

export const getTrack = async (id: string,
    params?: GetTrackParams, options?: RequestInit): Promise<getTrackResponse> => {
  
  const res = await fetch(getGetTrackUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getTrackResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getTrackResponse
}




export const getGetTrackKey = (id: string,
    params?: GetTrackParams,) => [`https://api.spotify.com/v1/tracks/${id}`, ...(params ? [params]: [])] as const;

export type GetTrackQueryResult = NonNullable<Awaited<ReturnType<typeof getTrack>>>

/**
 * @summary Get Track

 */
export const useGetTrack = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  id: string,
    params?: GetTrackParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getTrack>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(id)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetTrackKey(id,params) : null);
  const swrFn = () => getTrack(id,params, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Get Spotify catalog information for multiple tracks based on their Spotify IDs.

 * @summary Get Several Tracks

 */
export type getSeveralTracksResponse200 = {
  data: ManyTracksResponse
  status: 200
}

export type getSeveralTracksResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getSeveralTracksResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getSeveralTracksResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type getSeveralTracksResponseSuccess = (getSeveralTracksResponse200) & {
  headers: Headers;
};
export type getSeveralTracksResponseError = (getSeveralTracksResponse401 | getSeveralTracksResponse403 | getSeveralTracksResponse429) & {
  headers: Headers;
};

export type getSeveralTracksResponse = (getSeveralTracksResponseSuccess | getSeveralTracksResponseError)

export const getGetSeveralTracksUrl = (params: GetSeveralTracksParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/tracks?${stringifiedParams}` : `https://api.spotify.com/v1/tracks`
}

export const getSeveralTracks = async (params: GetSeveralTracksParams, options?: RequestInit): Promise<getSeveralTracksResponse> => {
  
  const res = await fetch(getGetSeveralTracksUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getSeveralTracksResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getSeveralTracksResponse
}




export const getGetSeveralTracksKey = (params: GetSeveralTracksParams,) => [`https://api.spotify.com/v1/tracks`, ...(params ? [params]: [])] as const;

export type GetSeveralTracksQueryResult = NonNullable<Awaited<ReturnType<typeof getSeveralTracks>>>

/**
 * @summary Get Several Tracks

 */
export const useGetSeveralTracks = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params: GetSeveralTracksParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getSeveralTracks>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetSeveralTracksKey(params) : null);
  const swrFn = () => getSeveralTracks(params, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Get a list of the songs saved in the current Spotify user's 'Your Music' library.

 * @summary Get User's Saved Tracks

 */
export type getUsersSavedTracksResponse200 = {
  data: PagingSavedTrackObjectResponse
  status: 200
}

export type getUsersSavedTracksResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getUsersSavedTracksResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getUsersSavedTracksResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type getUsersSavedTracksResponseSuccess = (getUsersSavedTracksResponse200) & {
  headers: Headers;
};
export type getUsersSavedTracksResponseError = (getUsersSavedTracksResponse401 | getUsersSavedTracksResponse403 | getUsersSavedTracksResponse429) & {
  headers: Headers;
};

export type getUsersSavedTracksResponse = (getUsersSavedTracksResponseSuccess | getUsersSavedTracksResponseError)

export const getGetUsersSavedTracksUrl = (params?: GetUsersSavedTracksParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/me/tracks?${stringifiedParams}` : `https://api.spotify.com/v1/me/tracks`
}

export const getUsersSavedTracks = async (params?: GetUsersSavedTracksParams, options?: RequestInit): Promise<getUsersSavedTracksResponse> => {
  
  const res = await fetch(getGetUsersSavedTracksUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getUsersSavedTracksResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getUsersSavedTracksResponse
}




export const getGetUsersSavedTracksKey = (params?: GetUsersSavedTracksParams,) => [`https://api.spotify.com/v1/me/tracks`, ...(params ? [params]: [])] as const;

export type GetUsersSavedTracksQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersSavedTracks>>>

/**
 * @summary Get User's Saved Tracks

 */
export const useGetUsersSavedTracks = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params?: GetUsersSavedTracksParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getUsersSavedTracks>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetUsersSavedTracksKey(params) : null);
  const swrFn = () => getUsersSavedTracks(params, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Save one or more tracks to the current user's 'Your Music' library.

 * @summary Save Tracks for Current User

 */
export type saveTracksUserResponse200 = {
  data: void
  status: 200
}

export type saveTracksUserResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type saveTracksUserResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type saveTracksUserResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type saveTracksUserResponseSuccess = (saveTracksUserResponse200) & {
  headers: Headers;
};
export type saveTracksUserResponseError = (saveTracksUserResponse401 | saveTracksUserResponse403 | saveTracksUserResponse429) & {
  headers: Headers;
};

export type saveTracksUserResponse = (saveTracksUserResponseSuccess | saveTracksUserResponseError)

export const getSaveTracksUserUrl = (params: SaveTracksUserParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/me/tracks?${stringifiedParams}` : `https://api.spotify.com/v1/me/tracks`
}

export const saveTracksUser = async (saveTracksUserBody: SaveTracksUserBody,
    params: SaveTracksUserParams, options?: RequestInit): Promise<saveTracksUserResponse> => {
  
  const res = await fetch(getSaveTracksUserUrl(params),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      saveTracksUserBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: saveTracksUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as saveTracksUserResponse
}




export const getSaveTracksUserMutationFetcher = (params: SaveTracksUserParams, options?: RequestInit) => {
  return (_: Key, { arg }: { arg: SaveTracksUserBody }) => {
    return saveTracksUser(arg, params, options);
  }
}
export const getSaveTracksUserMutationKey = (params: SaveTracksUserParams,) => [`https://api.spotify.com/v1/me/tracks`, ...(params ? [params]: [])] as const;

export type SaveTracksUserMutationResult = NonNullable<Awaited<ReturnType<typeof saveTracksUser>>>

/**
 * @summary Save Tracks for Current User

 */
export const useSaveTracksUser = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params: SaveTracksUserParams, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof saveTracksUser>>, TError, Key, SaveTracksUserBody, Awaited<ReturnType<typeof saveTracksUser>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getSaveTracksUserMutationKey(params);
  const swrFn = getSaveTracksUserMutationFetcher(params, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Remove one or more tracks from the current user's 'Your Music' library.

 * @summary Remove User's Saved Tracks

 */
export type removeTracksUserResponse200 = {
  data: void
  status: 200
}

export type removeTracksUserResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type removeTracksUserResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type removeTracksUserResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type removeTracksUserResponseSuccess = (removeTracksUserResponse200) & {
  headers: Headers;
};
export type removeTracksUserResponseError = (removeTracksUserResponse401 | removeTracksUserResponse403 | removeTracksUserResponse429) & {
  headers: Headers;
};

export type removeTracksUserResponse = (removeTracksUserResponseSuccess | removeTracksUserResponseError)

export const getRemoveTracksUserUrl = (params: RemoveTracksUserParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/me/tracks?${stringifiedParams}` : `https://api.spotify.com/v1/me/tracks`
}

export const removeTracksUser = async (removeTracksUserBody: RemoveTracksUserBody,
    params: RemoveTracksUserParams, options?: RequestInit): Promise<removeTracksUserResponse> => {
  
  const res = await fetch(getRemoveTracksUserUrl(params),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      removeTracksUserBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: removeTracksUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as removeTracksUserResponse
}




export const getRemoveTracksUserMutationFetcher = (params: RemoveTracksUserParams, options?: RequestInit) => {
  return (_: Key, { arg }: { arg: RemoveTracksUserBody }) => {
    return removeTracksUser(arg, params, options);
  }
}
export const getRemoveTracksUserMutationKey = (params: RemoveTracksUserParams,) => [`https://api.spotify.com/v1/me/tracks`, ...(params ? [params]: [])] as const;

export type RemoveTracksUserMutationResult = NonNullable<Awaited<ReturnType<typeof removeTracksUser>>>

/**
 * @summary Remove User's Saved Tracks

 */
export const useRemoveTracksUser = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params: RemoveTracksUserParams, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof removeTracksUser>>, TError, Key, RemoveTracksUserBody, Awaited<ReturnType<typeof removeTracksUser>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getRemoveTracksUserMutationKey(params);
  const swrFn = getRemoveTracksUserMutationFetcher(params, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Check if one or more tracks is already saved in the current Spotify user's 'Your Music' library.

 * @summary Check User's Saved Tracks

 */
export type checkUsersSavedTracksResponse200 = {
  data: ArrayOfBooleansResponse
  status: 200
}

export type checkUsersSavedTracksResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type checkUsersSavedTracksResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type checkUsersSavedTracksResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type checkUsersSavedTracksResponseSuccess = (checkUsersSavedTracksResponse200) & {
  headers: Headers;
};
export type checkUsersSavedTracksResponseError = (checkUsersSavedTracksResponse401 | checkUsersSavedTracksResponse403 | checkUsersSavedTracksResponse429) & {
  headers: Headers;
};

export type checkUsersSavedTracksResponse = (checkUsersSavedTracksResponseSuccess | checkUsersSavedTracksResponseError)

export const getCheckUsersSavedTracksUrl = (params: CheckUsersSavedTracksParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/me/tracks/contains?${stringifiedParams}` : `https://api.spotify.com/v1/me/tracks/contains`
}

export const checkUsersSavedTracks = async (params: CheckUsersSavedTracksParams, options?: RequestInit): Promise<checkUsersSavedTracksResponse> => {
  
  const res = await fetch(getCheckUsersSavedTracksUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: checkUsersSavedTracksResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as checkUsersSavedTracksResponse
}




export const getCheckUsersSavedTracksKey = (params: CheckUsersSavedTracksParams,) => [`https://api.spotify.com/v1/me/tracks/contains`, ...(params ? [params]: [])] as const;

export type CheckUsersSavedTracksQueryResult = NonNullable<Awaited<ReturnType<typeof checkUsersSavedTracks>>>

/**
 * @summary Check User's Saved Tracks

 */
export const useCheckUsersSavedTracks = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params: CheckUsersSavedTracksParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof checkUsersSavedTracks>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getCheckUsersSavedTracksKey(params) : null);
  const swrFn = () => checkUsersSavedTracks(params, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Get audio features for multiple tracks based on their Spotify IDs.

 * @summary Get Tracks' Audio Features

 */
export type getSeveralAudioFeaturesResponse200 = {
  data: ManyAudioFeaturesResponse
  status: 200
}

export type getSeveralAudioFeaturesResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getSeveralAudioFeaturesResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getSeveralAudioFeaturesResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type getSeveralAudioFeaturesResponseSuccess = (getSeveralAudioFeaturesResponse200) & {
  headers: Headers;
};
export type getSeveralAudioFeaturesResponseError = (getSeveralAudioFeaturesResponse401 | getSeveralAudioFeaturesResponse403 | getSeveralAudioFeaturesResponse429) & {
  headers: Headers;
};

export type getSeveralAudioFeaturesResponse = (getSeveralAudioFeaturesResponseSuccess | getSeveralAudioFeaturesResponseError)

export const getGetSeveralAudioFeaturesUrl = (params: GetSeveralAudioFeaturesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/audio-features?${stringifiedParams}` : `https://api.spotify.com/v1/audio-features`
}

export const getSeveralAudioFeatures = async (params: GetSeveralAudioFeaturesParams, options?: RequestInit): Promise<getSeveralAudioFeaturesResponse> => {
  
  const res = await fetch(getGetSeveralAudioFeaturesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getSeveralAudioFeaturesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getSeveralAudioFeaturesResponse
}




export const getGetSeveralAudioFeaturesKey = (params: GetSeveralAudioFeaturesParams,) => [`https://api.spotify.com/v1/audio-features`, ...(params ? [params]: [])] as const;

export type GetSeveralAudioFeaturesQueryResult = NonNullable<Awaited<ReturnType<typeof getSeveralAudioFeatures>>>

/**
 * @summary Get Tracks' Audio Features

 */
export const useGetSeveralAudioFeatures = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params: GetSeveralAudioFeaturesParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getSeveralAudioFeatures>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetSeveralAudioFeaturesKey(params) : null);
  const swrFn = () => getSeveralAudioFeatures(params, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Get audio feature information for a single track identified by its unique
Spotify ID.

 * @summary Get Track's Audio Features

 */
export type getAudioFeaturesResponse200 = {
  data: OneAudioFeaturesResponse
  status: 200
}

export type getAudioFeaturesResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getAudioFeaturesResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getAudioFeaturesResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type getAudioFeaturesResponseSuccess = (getAudioFeaturesResponse200) & {
  headers: Headers;
};
export type getAudioFeaturesResponseError = (getAudioFeaturesResponse401 | getAudioFeaturesResponse403 | getAudioFeaturesResponse429) & {
  headers: Headers;
};

export type getAudioFeaturesResponse = (getAudioFeaturesResponseSuccess | getAudioFeaturesResponseError)

export const getGetAudioFeaturesUrl = (id: string,) => {


  

  return `https://api.spotify.com/v1/audio-features/${id}`
}

export const getAudioFeatures = async (id: string, options?: RequestInit): Promise<getAudioFeaturesResponse> => {
  
  const res = await fetch(getGetAudioFeaturesUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getAudioFeaturesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getAudioFeaturesResponse
}




export const getGetAudioFeaturesKey = (id: string,) => [`https://api.spotify.com/v1/audio-features/${id}`] as const;

export type GetAudioFeaturesQueryResult = NonNullable<Awaited<ReturnType<typeof getAudioFeatures>>>

/**
 * @summary Get Track's Audio Features

 */
export const useGetAudioFeatures = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  id: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getAudioFeatures>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(id)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetAudioFeaturesKey(id) : null);
  const swrFn = () => getAudioFeatures(id, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Get a low-level audio analysis for a track in the Spotify catalog. The audio analysis describes the track‚Äôs structure and musical content, including rhythm, pitch, and timbre.

 * @summary Get Track's Audio Analysis

 */
export type getAudioAnalysisResponse200 = {
  data: OneAudioAnalysisResponse
  status: 200
}

export type getAudioAnalysisResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getAudioAnalysisResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getAudioAnalysisResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type getAudioAnalysisResponseSuccess = (getAudioAnalysisResponse200) & {
  headers: Headers;
};
export type getAudioAnalysisResponseError = (getAudioAnalysisResponse401 | getAudioAnalysisResponse403 | getAudioAnalysisResponse429) & {
  headers: Headers;
};

export type getAudioAnalysisResponse = (getAudioAnalysisResponseSuccess | getAudioAnalysisResponseError)

export const getGetAudioAnalysisUrl = (id: string,) => {


  

  return `https://api.spotify.com/v1/audio-analysis/${id}`
}

export const getAudioAnalysis = async (id: string, options?: RequestInit): Promise<getAudioAnalysisResponse> => {
  
  const res = await fetch(getGetAudioAnalysisUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getAudioAnalysisResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getAudioAnalysisResponse
}




export const getGetAudioAnalysisKey = (id: string,) => [`https://api.spotify.com/v1/audio-analysis/${id}`] as const;

export type GetAudioAnalysisQueryResult = NonNullable<Awaited<ReturnType<typeof getAudioAnalysis>>>

/**
 * @summary Get Track's Audio Analysis

 */
export const useGetAudioAnalysis = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  id: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getAudioAnalysis>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(id)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetAudioAnalysisKey(id) : null);
  const swrFn = () => getAudioAnalysis(id, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * Recommendations are generated based on the available information for a given seed entity and matched against similar artists and tracks. If there is sufficient information about the provided seeds, a list of tracks will be returned together with pool size details.

For artists and tracks that are very new or obscure there might not be enough data to generate a list of tracks.

 * @summary Get Recommendations

 */
export type getRecommendationsResponse200 = {
  data: OneRecommendationsResponse
  status: 200
}

export type getRecommendationsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getRecommendationsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getRecommendationsResponse429 = {
  data: TooManyRequestsResponse
  status: 429
}
    
export type getRecommendationsResponseSuccess = (getRecommendationsResponse200) & {
  headers: Headers;
};
export type getRecommendationsResponseError = (getRecommendationsResponse401 | getRecommendationsResponse403 | getRecommendationsResponse429) & {
  headers: Headers;
};

export type getRecommendationsResponse = (getRecommendationsResponseSuccess | getRecommendationsResponseError)

export const getGetRecommendationsUrl = (params?: GetRecommendationsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.spotify.com/v1/recommendations?${stringifiedParams}` : `https://api.spotify.com/v1/recommendations`
}

export const getRecommendations = async (params?: GetRecommendationsParams, options?: RequestInit): Promise<getRecommendationsResponse> => {
  
  const res = await fetch(getGetRecommendationsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getRecommendationsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getRecommendationsResponse
}




export const getGetRecommendationsKey = (params?: GetRecommendationsParams,) => [`https://api.spotify.com/v1/recommendations`, ...(params ? [params]: [])] as const;

export type GetRecommendationsQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendations>>>

/**
 * @summary Get Recommendations

 */
export const useGetRecommendations = <TError = Promise<UnauthorizedResponse | ForbiddenResponse | TooManyRequestsResponse>>(
  params?: GetRecommendationsParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getRecommendations>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetRecommendationsKey(params) : null);
  const swrFn = () => getRecommendations(params, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
